name: Build and test ecli on aarch64

on:
  push:
    branches: ["*"]
    paths:
      - "ecli/**"
      - "compiler/**"  # Ensure ecc and ecli releasing at same time
      - "wasm-rumtime/**"  # Release when dependencies updated
      - "third_party/**"
      - "bpf-loader-rs/**"
      - "eunomia-sdk/**"
      - ".github/**"

  pull_request:
    branches: ["*"]
    paths:
      - "ecli/**"
      - "compiler/**"
      - "wasm-rumtime/**"
      - "third_party/**"
      - "bpf-loader-rs/**"
      - "eunomia-sdk/**"
      - ".github/**"
env:
  BUILD_TYPE: Release
  INSTALL_LOCATION: .local

jobs:
  build-full-client:
    runs-on: ubuntu-22.04
    if: "!contains(github.event.head_commit.message, '[skip ci]') && !contains(github.event.head_commit.message, '[ci skip]')"
    steps:
    - uses: actions/checkout@v3
      with:
        submodules: 'recursive'
    - name: Install dependencies for cross-building
      run: |
        sudo apt-get update
        sudo apt-get install -y g++-aarch64-linux-gnu gcc-aarch64-linux-gnu
    - name: Clone libbpf for building
      run: |
        git clone https://github.com/libbpf/libbpf

    - name: Build libbpf in a qemu virtual machine, and copy libs out
      uses: uraimo/run-on-arch-action@v2
      with: 
        arch: aarch64
        distro: ubuntu22.04
        run: |
          apt-get update
          apt-get install -y zlib1g-dev libelf-dev gcc make pkg-config
          cd /libbpf/src
          make
          cp libbpf.so /libs
          cp /usr/lib/aarch64-linux-gnu/libelf.so /libs
          cp /usr/lib/aarch64-linux-gnu/libz.so /libs
        dockerRunArgs: |
          --volume "${PWD}/libbpf:/libbpf"
          --volume "${PWD}/libs:/libs"
    - name: Upload copied libs for testing
      uses: actions/upload-artifact@v3
      with:
        name: aarch64-libs
        path: libs
    - name: Build ecli client
      run: |
        rustup target add aarch64-unknown-linux-gnu
        # Install them, so that libbpf will find their headers
        sudo apt-get install libelf-dev zlib1g-dev
        cd ecli/client
        RUSTFLAGS="-L $(pwd)/../../libs" cargo build --release --target aarch64-unknown-linux-gnu
        cd ../..
        cp ./ecli/target/aarch64-unknown-linux-gnu/release/ecli-rs .
        mkdir data
        cp ecli-rs data
    - name: Run ecli and see what libs were loaded
      uses: uraimo/run-on-arch-action@v2
      with: 
        arch: aarch64
        distro: ubuntu22.04
        run: |
          apt-get update
          apt-get install -y libelf zlib1g
          echo "Installation done"
          echo "Working directory $(pwd)"
          chmod +x /data/ecli-rs
          echo "Permission set done"
          chmod +x /data/copy-libs.sh
          /data/copy-libs.sh /data/ecli-rs
        dockerRunArgs: |
          --volume "${PWD}/data:/data"
        shell: /bin/bash
    - name: Show what libraries were copied
      run: |
        sudo chmod 777 ./data -R
        sudo chown $(whoami) ./data -R
        find ./data/libs -type f
    - name: Prepare runtime file and cargo-appimage tool
      uses: eunomia-bpf/prepare-cargo-appimage@v6
      with: 
        runtime-url: https://github.com/eunomia-bpf/prepare-cargo-appimage/raw/v6/runtime-aarch64
    - name: Install libfuse for appimagetool
      run: |
        sudo apt-get update
        sudo apt-get install libfuse2
    - name: Clone and install cargo-appimage with aarch64 launcher
      run: |
        git clone https://github.com/eunomia-bpf/cargo-appimage
        cd cargo-appimage
        CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc RUSTFLAGS="-C target-feature=+crt-static" cargo build --release --target aarch64-unknown-linux-gnu

  build-ecli-server:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          submodules: 'recursive'
      - name: Prepare cargo-appimage
        uses: eunomia-bpf/prepare-cargo-appimage@v5
      - name: Install libfuse
        run: |
          sudo apt-get install -y libfuse2
      - name: Build ecli-server
        run: |
          sudo make install-deps
          cd ecli/server
          CARGO_APPIMAGE_TOOL_BIN=../../appimagetool CARGO_APPIMAGE_RUNTIME_FILE=../../runtime CARGO_APPIMAGE_OUT_FILE=ecli-server cargo appimage
      - name: Package ecli-server
        run: |
          cp ecli/server/ecli-server .
          tar -czvf ecli-server.tar.gz ecli-server 
      - name: Test CLI
        run: |
          mkdir cli-test
          cd cli-test
          ../ecli-server -h
          sudo timeout -s 2 3 ../ecli-server || if [ $? = 124 ]; then exit 0; else exit $?; fi
      - name: Rename `ecli-server.tar.gz` to proper name
        id: name
        run: |
          mv ecli-server.tar.gz ecli-server-ubuntu-latest.tar.gz
          echo "zip_name=ecli-server-ubuntu-latest.tar.gz" >> "$GITHUB_OUTPUT"
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with: 
          # name: "ecli-server-${{needs.create-release-version.outputs.version}}"
          path: |
            ${{steps.name.outputs.zip_name}}
          
  # publish-release:
  #   runs-on: ubuntu-latest
  #   needs: [create-release-version, build-full-client, build-http-only-client, build-native-only-client, build-ecli-server]
  #   steps:
  #     - name: Download build results
  #       uses: actions/download-artifact@v3
  #       with:
  #         path: results
  #     - name: List files to release
  #       id: list-files
  #       run: |
  #         EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
  #         FILES=`find ./results -type f`
  #         echo "$FILES"
  #         echo "upload_files<<$EOF" >> "$GITHUB_OUTPUT"
  #         echo "$FILES" >> "$GITHUB_OUTPUT"
  #         echo "$EOF" >> "$GITHUB_OUTPUT"
  #     - name: Publish
  #       if:   github.event_name == 'push' && github.ref == 'refs/heads/master' && github.repository_owner == 'eunomia-bpf'
  #       uses: softprops/action-gh-release@v1
  #       with:
  #           files: ${{steps.list-files.outputs.upload_files}}
  #           prerelease: false
  #           tag_name: ${{ needs.create-release-version.outputs.version }}
  #           generate_release_notes: true
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
